#!/usr/bin/env bash

set -o errexit

# Global constants
declare -r \
	gitname='github-actions' \
	gitemail='41898282+github-actions[bot]@users.noreply.github.com' \
	apibaseurl='https://api.github.com'

# Print error message and exit
die() {
	printf '%s\n' "$*" >&2
	exit 1
}

# List all semver tags minus the "v" and sort them; busybox sort doesn't have
# version sort
gettags() {
	git tag \
		| sed -rn 's/v(([[:digit:]]+\.){2}[[:digit:]]+)/\1/p' \
		| sort -t. -n -k1,1 -k2,2 -k3,3
}

# Get SHA of object ref points to
getparentsha() {
	local ref=$1
	git rev-parse --verify "$ref^{}"
}

# Make POST API call to GitHub API; respfilter is a jq filter to be applied to
# the response
makeapipostcall() {
	local route=$1
	local payload=$2
	local respfilter=$3
	local res

	if ! res=$(
		curl \
			--fail \
			--location \
			--silent \
			--show-error \
			--header "Content-Type: application/json" \
			--header "Accept: application/vnd.github.v3+json" \
			--header "User-Agent: bewuethr/release-tracker-action" \
			--header "Authorization: Bearer $GITHUB_TOKEN" \
			--data-raw "$payload" \
			"$apibaseurl$route"
	); then
		die "curl unsuccessful"
	fi
	jq -r "$respfilter" <<< "$res"
}

# Create an annotated tag: create a tag object, then a tag reference
createannotatedtag() {
	local tag=$1
	local semvertag=$2

	# Find SHA of object tag points to
	local sha
	sha=$(getparentsha "$semvertag")

	git tag --annotate --message="latest release in $tag" "$tag" "$sha"
	git push --follow-tags
	return 0

	# Create tag object
	local message="latest release in $tag\n"
	local payload
	payload=$(
		cat <<- EOF
			{
			  "tag": "$tag",
			  "message": "$message",
			  "object": "$sha",
			  "type": "commit",
			  "tagger": {
			    "name": "$gitname",
			    "email": "$gitemail"
			  }
			}
		EOF
	)

	local tagsha
	echo "Making API call to create tag object for $tag..."
	tagsha=$(makeapipostcall "/repos/$GITHUB_REPOSITORY/git/tags" "$payload" '.sha')

	# Create tag reference
	payload=$(
		cat <<- EOF
			{
			  "ref": "refs/tags/$tag",
			  "sha": "$tagsha"
			}
		EOF
	)

	echo "Making API call to create reference for $tag..."
	makeapipostcall "/repos/$GITHUB_REPOSITORY/git/refs" "$payload" '.'
}

# Suppress detached HEAD warning
git config advice.detachedHead false

# Clobber local tags
git fetch --tags --force

# Build associative array of most recent major and minor releases
declare -A latest

echo "Building tag table..."
while IFS=. read -r major minor patch; do
	latest["v$major"]="v$major.$minor.$patch"
	latest["v$major.$minor"]="v$major.$minor.$patch"
done < <(gettags)

# Move or create tags
for tag in "${!latest[@]}"; do
	echo "Checking $tag..."
	semvertag=${latest["$tag"]}
	if git show-ref --tags --quiet "$tag"; then
		if [[ $(getparentsha "$tag") == $(getparentsha "$semvertag") ]]; then
			echo "$tag already points to same commit as $semvertag, skipping..."
			continue
		fi
		# Delete local and remote tag
		echo "Deleting $tag..."
		git tag --delete "$tag"
		git push --delete origin "$tag"
	fi
	echo "Creating annotated tag $tag pointing to same commit as $semvertag..."
	createannotatedtag "$tag" "$semvertag"
done
